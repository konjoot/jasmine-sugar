define 'interface', ->
  (Jasmine, Wrapper)->
    return {} unless Jasmine
    return {} unless Wrapper

    currentContext  =
    currentCallback = undefined

    # @set = ->
      # try
      #   callback.apply(this)
      # catch e
      #   switch e.name
      #     when 'ReferenceError'
      #       newCallback = new CallbackWrapper(callback)
      #       newCallback.apply(this)

    @set = (callback)->
      currentCallback = callback
      currentContext  = this

      runCallback.with preparedContext()

    runCallback =
      with: (context)->
        console.log currentCallback.toString()
        console.log context
        fn1 = -> this.collection.letBe()
        fn2 = -> console.log collection.letBe()
        fn1.call(context)
        fn2.call(context)
        # fn = eval.call(context, new Function('console.log(collection);'))
        # fn()
        # currentCallback.call(context)

    preparedContext = ->
      context = new Context()
      for prop in callbackProperties()
        console.log 'before prop definition'
        context.defineProperty(prop)
        console.log 'after prop definition'

      # currentContext.clear = ->
      #   for prop in assignedProperties
      #     delete currentContext[prop]

      context

    callbackProperties = ->
      ['collection']

    Context = ->
      context = this

      @defineProperty = (prop)->
        context[prop] =
          letBe: -> console.log "defined"

        console.log context[prop].letBe.toString()
        console.log "var #{prop} = this['#{prop}'];"

        eval.call(context, "var #{prop} = this['#{prop}'];")

        true

      this


    autoGeneratedMethods = ['it', 'iit', 'fit', 'xit']

    # genarating the following functions:
    # @it = ()->
    #   Jasmine.it.apply(
    #     this,
    #     Wrapper(arguments...).it()
    #   )

    # @iit = ()->
    #   Jasmine.iit.apply(
    #     this,
    #     Wrapper(arguments...).it()
    #   )

    # @fit = ()->
    #   Jasmine.fit.apply(
    #     this,
    #     Wrapper(arguments...).it()
    #   )

    # @xit = ()->
    #   Jasmine.xit.apply(
    #     this,
    #     Wrapper(arguments...).it()
    #   )

    for method in autoGeneratedMethods
      if Jasmine.hasOwnProperty(method) and typeof(Jasmine[method]) == 'function'
        this[method] = do (method = method)->
          ->
            Jasmine[method].apply(this,
              Wrapper(arguments...).it())

    this