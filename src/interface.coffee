define 'interface', ->
  (Jasmine, Wrapper)->
    return {} unless Jasmine
    return {} unless Wrapper

    @set = (fn)->
      callback = new Callback(fn)

      callback.run()

    Callback = (fn)->
      properties = do ->
        ['collection']

      PreparedContext = do ->
        context = new Context()

        for prop in properties
          context.defineProperty(prop)

        context

      @run = ->
        do (context = PreparedContext)->
          for obj of context.properties
            eval('var ' + obj + ' = (' + context.properties[obj].toString() + ')(' + '"' + obj + '"' + ');')

          eval('(' + fn.toString() + ')')()

      this

    Context = ->
      private_context = {}

      @defineProperty = (prop)->
        private_context[prop] = (prop)->
          letBe: -> console.log "#{prop} defined"

        true

      @properties = private_context

      this


    autoGeneratedMethods = ['it', 'iit', 'fit', 'xit']

    # genarating the following functions:
    # @it = ()->
    #   Jasmine.it.apply(
    #     this,
    #     Wrapper(arguments...).it()
    #   )

    # @iit = ()->
    #   Jasmine.iit.apply(
    #     this,
    #     Wrapper(arguments...).it()
    #   )

    # @fit = ()->
    #   Jasmine.fit.apply(
    #     this,
    #     Wrapper(arguments...).it()
    #   )

    # @xit = ()->
    #   Jasmine.xit.apply(
    #     this,
    #     Wrapper(arguments...).it()
    #   )

    for method in autoGeneratedMethods
      if Jasmine.hasOwnProperty(method) and typeof(Jasmine[method]) == 'function'
        this[method] = do (method = method)->
          ->
            Jasmine[method].apply(this,
              Wrapper(arguments...).it())

    this